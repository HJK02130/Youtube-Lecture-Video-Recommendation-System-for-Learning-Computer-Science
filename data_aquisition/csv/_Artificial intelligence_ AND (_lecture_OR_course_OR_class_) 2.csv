id,categoryId,description,publishedAt,title,thmbnails,channelTitle,duration,caption,viewCount,likeCount,dislikeCount,favoriteCount,commentCount,subtitle
snqeJed-lAk,27,This lecture provides an overview of the LISP and Scheme programming languages. The lecture goes over an overview of what functional programming languages are and how they are used to solve problems. Dr. Racket installation and usage is also demonstrated.,2012-10-20T22:36:32Z,Artificial Intelligence - Lecture 5,https://i.ytimg.com/vi/snqeJed-lAk/hqdefault.jpg,Barbara Hecker,PT1H21M48S,false,3394,12,0,0,1,"okay everybody welcome back to day number two so today is actually not gonna be too bad so yesterday wasn't too bad but as a student I can as a teacher I could say it's not too bad as a student I could say that's probably didn't perspective but anyway yeah so we're gonna start in with two programming languages today the first one we're gonna look at is scheme or Lisp and the second one we look at is Prolog probably won't get the Prolog till tomorrow so we'll see what happens because we have two activities we need to do today we have kind of a short half-day kind of format going on today but don't worry I will get everything done so what you're gonna need to do what we should have covered this morning that I'm gonna save you the boredom of covering would have been lecture number four and lecture number five going through all those searching algorithms so if you read the chapters on inform search and uninformed search and if you remember what I was talking about towards the end of yesterday that would have been the stuff I would have covered this morning instead I'm gonna kind of wait I might get to it eventually but I'm going to put a higher priority on scheme so the lecture I'm gonna do right now is from the Viacom website and it is the one that is titled this back this L is P tutorial so I'm gonna go through the tutorial and about half way I'm going to stop we're gonna download and I have a Windows partition on this computer so I'm going to download dr. racket and we'll see the examples work and so you'll be able to be functional you're gonna learn a new programming language today and now I'll tell you why you're gonna learn in a few minutes when I start the lecture but that's the game plan for this particular lecture so if you download the lecture a is Lisp dot PPT that's what I'm looking at right now so what is Lisp let's see if I can get started first here goes brief introduction to Lisp and scheme the two languages are very similar so back in the 1950s and people had all of this data and we talked about data and knowledge representation yesterday and data representation so the day is on the computer and we want to use the computer to help us analyze the data so we can artificially figure out stuff trend and weather patterns I don't know what member of this list is also a member of that list and so list came around so Lisp is for list processing takes on an entire list of information compares it against another list sorts the list searches the list performs a lot of automation that would otherwise be very tedious so it's a it's an attempt to sort of automate automate the AI concept of sorting and searching through the data so the concept of assignment is not part of functional languages and by the way this falls in the category of a pure functional language it's functional because its function based and you don't have to know anything about programming anything about any of the languages to understand all this in fact people who use this scheme and Prolog are not computer science people there are artificial intelligence researchers that use these languages so no no prior programming experience is required so where we got here we have no assignment statements we have no variables that are bound to any values so all that stuff even if you know programming all that stuff's not going to help you anyway we have function calls that have no side effects we have no global state so we also have in terms of flow control there's no iteration there's no repetition but there is recursion and so for those people who know about recursion they always go you know they always like you usually shape or do something I don't like recursion don't worry about it it's actually not too bad with this language so we have it's called referential transparency this is just your vocabulary today and it's the value of the function application which is independent of the context in which it occurs so the value of function ABC depends on only the values of a B and C so every time you run the values with the same function with the same values you get the same response regardless so it always acts the same way all variables in functions must also be local there is no global scope there's only a local scope with this and there's nothing depends on the global state everything is separated out in terms of its functionality and in terms of its scope of a scope also another characteristic of pure functional language is that the old storage is implicit so there's no copy semantics which needs garbage collection and we're going to see how that works actually with scheme but the concept is we just fill a memory up with filled a memory up and then eventually we have to dump the memory out because we're going to fill it up too much so functions are also first-class values so it can be passed as arguments and you can be returned as values of expressions as well and can be put in data structures and convenience for multiple different purposes so and I kind of skipped through this because this is 160 or so slides you don't want to go through all this stuff everything you ever wanted to know about the language instead and I'm not gonna compare instead I'm just gonna get right to the nitty-gritty details of what this language entails okay so it was not made for programmers and was made for scientists it was made for math people made for data crunchers so they loved Lamba expressions and lambda calculus you guys don't like that because you guys are programmers you like so there's a there's an alternative choice however the current ie des come out will allow you to use variables allowing you to use things that are you're familiar with and not have to worry about the lambda calculus however I sort of need to explain what this is so you kind of have an idea about how the function works so mathematical functions is a mapping of the members of one set called the domain set to another set called the range set so for the domain we're going to match it with this range of values that we have received from our experimental results from our AI experiment that we conducted and so we're taking one set we're matching it with another set or we're applying a function to all of the values that we have received from a particular set so thing about sets of data think about lists of data and functions that might be performed on this data which is what this language does so the lambda expression itself specifies the parameters and the mapping of the function and following form so we have the land to expression of X which is really the function of X which is equal to X times X times X times that you know 3x is x times X times X which is X cubed if you think about it but we have this for the function this is what you're gonna probably going to you're is what you're gonna write this is what you're gonna use you're gonna say Cuba but in the beginning they didn't have you know the concept of naming a function so it's just a declare a function and in the old days we used to have these symbols that we could actually just you know put in there click on it so monitor keyboards I don't think that expression isn't even on the keyboard anywhere I don't see it on my keyboard so you know basically we'd have to work with old antiquated kind of environments to actually even write with this syntax if you were programming this way so this is the expression here which is basically the same this is nameless this has a name so you're probably gonna be naming your stuff and we'll see in a few minutes how the stuff works so the lam expressions are describing nameless functions which is really the equivalent so these two are the same by the way and this is gonna say the function of X so the f of X is going to be equal to and this is I'm going to go back to Algebra one I would say you'd get the concept and maybe this might even be pretty math pre-algebra but anyway let me express this you're also play to parameters so by placing the parameter in the expression here three we apply three and substitute for X so it's kind of interesting we create the formula which is um the scheme is very similar to math lab which is very similar to some other functional programming languages that are used for mathematics movies for automation of kind of certain calculations which is what they're used for in artificial intelligence as well so here if we substitute three and then we have three times three times three which is going to give us the value of 27 and here too so you substitute 2 in but this is a different expression this one has the value two so it would be 2 times 2 plus 3 and we get our response out of that so strictly function substitution from pre pre pre algebra math or algebra whatever it's not not rocket science ray it's not hard stuff function with forms so in Lisp we originally started out with three function forms we had the function composition the construction and the flight all so imagine you're not learning a programming language you're learning a function system and you have this list of data and you want to apply some functionality to it well you have three to choose from in this basic system so in this function form we're looking at a higher-order function is one that either takes functions as parameters or yields a function as its result or does both so we were sending a value here 3 where we can set a function to the function to the function to the function we can also have the function call itself over and over again so we can do an automatic Fibonacci calculation of summation all sorts of different neat stuff you like recursion so the function composition the construction and the apply to all are the three categories so the function composition is to compose the function in this particular case functional form it takes two functions as a parameter and then yields a function whose result is a functions and those values the first actual parameter function applied to the result of the application of the second parameter function we do this so we can stack it all up we don't do this we'll make it more confusing we do this we check up everything to automate it because if you think about the concept you have a list of thousands of items and another list of thousands of items you have to run a function on it first and then you have to run on a function on its second and they have to apply the second to the first or you have to figure you're gonna have two separate functions maybe that are running with this you stack it all up into one function call and you say go more automated then having to say okay here's the results from the first function return and let's apply it to the second function return little pry it to the third function return and then all of a sudden you go we applied the wrong one to want too much room for mistakes so if you can condense it on do it function composition on it you compose the function of other functions and you have one function that you're writing and you save the function a text file you load it up into the language system which we're going to see in a few minutes and then all of a sudden you know hey works hopefully so so here's the form here don't get caught up with the syntax in fact that's an interesting symbol the question mark inside of the tiger it means the symbols not here in my slides that are my fonts but anyway look at the bottom line here actually if f of X if you're gonna run f of X and you're gonna send G to f of X and G of X to f of X you're gonna run the inside and then you're gonna run the outside so just think of it more like you're sending a function call as a parameter to a function so you're gonna resolve it down from the innermost parameters it doesn't really matter what order the parameters our are evaluated in so you can't really assume it's left-to-right right-to-left it doesn't really matter they might be both done simultaneously if you have enough memory in the system actually so here if we have an f of X in it if it if that wouldn't equal two times X and G of X was equal to one minus X if we ran f of X with G of X as a parameter then we'd say F of F of G 3 is equal to F of G excuse me G to the sending 3 to the G function and then sending that result to the F function is what we're essentially doing so so 3 times 2 a little bit 6 6 - well we got 5 well ok we hit the wrong number here 3 well anyway you get the idea run the parameters first and then substitute parameter values from the expression into the outer expression terms of the construction actually here it is here it's a better way of presenting it makes more sense so the function form that takes a list as parameters a list a list of functions as a parameters and as a as the parameters and then yields a list of results by applying each of all of its function parameter functions to a given parameter so here we have the form F and G that are part of the function call and then f is x times X times X G is X plus 3 this is the second form of the function by the way so we have the construction excuse me we have what's we have the function composition as main form then we have the construction where we're gonna yield we put 4 in here for is going to be applied to the and then fourthly I applied to the G we're running a string of functions for the data because we want to run multiple functions one right after the other or maybe simultaneously on the data and we want to yield a final result and then in this particular case we'd get 64 and 7 take 4 plus 3 and then whatever I got 4 times 4 times 4 so we yield the two results this is called the construction where you're constructing a call to a function that consists of function calls and you're applying a list of data to that list of functions that you're gonna use in here don't worry about it we're gonna show you some examples you're going to see it work together this is the one is probably the most populous they apply to all so you have a bunch of strings and you want to convert them to floats or you have a bunch of strings and you want to find out the average of all of those integers or something and so we don't have types in this language so we don't have strings and floats and doubles and stuff we just have data so which is nice because it's not like it's not a strongly typed language so we don't really care what we have actually and the list can contain a number a string anything it wants so if we do an apply to all I'll get into that concept in a few minutes if we do apply to all the function form that takes a single function as a parameter and yields a list of values obtained by applying the given function to each element of the list so here we go for the form for x of h which is x times X times X times X apply here H to the numbers 3 2 & 4 so for this data we're applying this function to it so we get 27 864 that's all you're gonna need to really do in this class you're not gonna have to do anything else except well actually one of the assigns is gonna ask you for a recursive function and I'll go over that actually in a few minutes I'm gonna go over the first two assignments today as well so we know what we're supposed to be doing so that's essentially the mathematical basis for Lisp and then we ended up with another language called scheme where we were able to define functions I'm gonna skip it a little bit and talk about Lisp first I don't worry about the fundamentals of functional programming languages you can go ahead and read through this a little bit slower if you'd like uh so Lisp that's the basis that's the entire language by the way it just gave you the whole language so that's what the language does not a big language very small so functional languages developed it around the nineteen fifties this guy John McCarthy put this one together the semantics are based on lambda calculus so when Lisp was all lambda calculus not very user-friendly I mean it was not and it only had six basic functions and the six basic functions we're gonna see some examples of this today but cons car CD are equal and atom and then we had conditions well we had just one condition it's like the if n you know if excuse me if else kind of condition not too powerful but it was a useful for this processing useful for artificial intelligence applications and programs I can read generate other programs out of that because you can send a function to a function and you can get different results from different patterns so the idea is to put it together and then run your data through it and you'd have like a really good way of comparing the data sets if you ran it through in an automated way you're guaranteed to have the same calculations performed in each one regard so who did it so you put it into the program you loaded up the function put the data in there and then two weeks later you put another set of data in there two weeks later you put another and you have a really pretty good consistency among your apples and apples because one of the worst parts about doing research and data in terms of an AI because a lot of these problems solutions come come out of research and analyzing the data they say you know what you're looking at and you get data that oh yeah we did this to that data and this to that data and it's a total waste of time so it's really important actually to get some consistency in your results oh as you don't know if what you're doing is really effective so it's a common list was the first dialect of lists back from the 50s it was implemented it did not completely adhere to semantics it sort of went off and people say well Common Lisp made it try to make it a little bit easier so semantics that were redefined to match the implementation some of the wording was changed around so it became common list actually became the standard for and then scheme came out of Lisp so scheme is a language in the programming language trees started at the top excuse me lisp started at the top and then lisp a branched out into common lisp and then scheme they're both two languages or dialects of lisp which is kind of interesting many defined functions simple syntax large language your scheme scheme this was about the 1950s this was around the nineteen fifties late fifties Common Lisp was around hmm he didn't get unified till nineteen eighty schemes around 1972 kind of give you some some perspective on the development effort and the mid nineties said his dialect of listers I was designed to be cleaner more modern simpler version more contemporary not the Common Lisp which was kind of cryptic at the point so it uses static scoping functions are first class entities as well and it turned into a first functional programming language so from programming language concepts perspectives this is one of our first functional languages it was like the predecessor of a lot of our current functional languages that exist and the L is an example math lab is another example of functional languages so there are values of the expression and the elements of the lists that are contained and can be assigned to variables and passed as parameters and basically all the functional referential integrity and steps that I looked at before they were showing you in those examples applies towards scheme so the basic workings of Lisp and scheme are how the expressions are demonstrated so this is slide number 16 which is the start of the programming expressions so what I'm gonna do is kind of pause this moment here install doctor racket which is our scheme version and then we can see this stuff live actually we can see it work hopefully so I'm going to make this a little bit bigger get rid of this bottom screen so I'm gonna say you guys have one you can install this on windows or you can install this on the mac uh the process is the same and I'm gonna show you how but I'm gonna demo it on a Windows because I'm looking around and I see a majority of Windows computers so not to worry though you can install the same program on the Mac and here's how we do it so you're gonna open up Google download it hopefully have an internet connection let's see a bookmarked I bookmarked it here if you don't my Alexis if you don't want it I'll stop do the bookmark we'll just go like this will do the bookmark I'm sorry and your internet explorer in your Firefox or your Chrome or your Safari or in whatever it is that you might be using as a web browser go to racketlon org dr. racket is the current version of dr. scheme which is the current version of scheme from one area of research we have gnu racket virginia scheme works better on the mac actually the gnu stuff this one works better on Windows but I believe they're both compatible and the windows look the same when you get to this URL does anyone need this URL anymore hopefully you can see it's kind of light layer up there is kind of like everyone got it okay who's gonna do it okay if you click on the download racket button right here right underneath the down room bracket you'll see platform you click on the platform you'll see OS X you'll see the source here you'll see up here OS X Intel 32 PowerPC OS X Intel 64 bit it depends on the book you're on most of you probably you're gonna be over here and a 32-bit or 64-bit so it depends on which what you think you might have if you're a Windows person I'm on XP so I'm not gonna be on a 32-bit XP system it's not going to tell me it's just one Windows version it works on everything so if you're on seven windows version works non-experience so while you're doing that so select select the operating system you want click on the big download button and you'll see a little thing pop up no no little thing popped up now let's go oh yes here I'm sorry you have to pick the download site you get taken to the mirrored site I'm gonna pick a mainly in download Massachusetts now the little dialog comes up save it to your desktop huh let's see I'll save it to my desktop I'm gonna reinstall it so I installed it earlier just to test it but I'll reinstall it so you can follow through now while this is downloading I'm gonna show you something else I'm gonna open up another web browser window don't have to do this by the way I just want to show you your choices and this might take a few minutes because everyone's downloading it but if I go to Google here and I type in and I'm just showing you another alternative here GNU scheme and I go here to download or actually I probably could've clicked on this one right here mit has a current GNU scheme project out there you don't get the same GUI as you get with doctor racket which is in your nose whew you're gonna love the GUI in a few minutes you're gonna see what I'm talking about this one here is command line based it's mostly works great on Linux and UNIX and it works on the MacBook just fine as well and it does have a slight GUI interface to it I don't like it as much it's not as user friendly but if you want you can experiment with this one too this one used to actually be installed on earlier PowerPC versions of what was it I can't even run it was called now the Apple operating system like reversion seven or eight before we got OSX the camera man what's called right now but anyway long story short used to just like Python and Perl actually still come so does PHP and no more PHP we still get Python with current OSX this was one of those experimental languages it's free it's always been open session safe or it's open source so a lot of people are developing it my a few people aren't developing it for their AI research lab and they have different libraries that are supported in there you're gonna see when I bring it up that there's a couple of different options and a couple of different languages scheme there's no standard to this its developmental language so back at the ranch sure I'm gonna wait for my download to complete shouldn't be too long when the download completes this install takes about five seconds and what's the install happens and we configure it with a language has everybody downloading this is this why it's running so slowly okay all right so as soon as some of yours quits why not run faster so I meanwhile back at the ranch air will go back to the PowerPoint so basically what we're looking at is an infix so it's an infix parenthesized form of an expression so most people like the idea going one plus one and then they say their press return and nickels two three you know equals to two okay so now you have to get used to this form here plus one two and then you're gonna get three hopefully back out of this and you're gonna use parentheses here with every one of your expressions because what you're really doing is running functions and the functions that you're calling are using standard symbols and here we have plus and a minus we could actually type the word add instead but if there's a common dialect that's being used to kind of and I'll run these examples and we'll see this in a few minutes oh I heard someone's end okay good so as yours is ending mine's gonna end mine's gonna get faster I cannot believe that we don't have the bandwidth for everyone to download this but I shouldn't complain actually I was at the GMAC conference earlier we had the same problem something there was no no internet access I mean everybody was on it and they were all downloading a PDF file I sold on the download and it was just like this was I think sounds a convention so you'd think they'd have better internet access apparently there's limitations so all right so I'll give it a few more minutes we'll be patient so what we're looking at that is running functions and we have built-in functions in here we have length which is a built-in function that gives us a link and then we have this little apostrophe here they posture Peter says treat them like variables and not like functions treat them like menu items so and we'll see that actually in here I'm gonna skip ahead a little bit explain about the Posterous ' come back except for I can't get ahead a little bit here we go so here's our posture P so our constants so to get scheme to treat an S expression as a constant rather than as a function application or name reference you precede them with this ' so a posture be 1 2 3 gives us 1 2 3 as a value and this is going to be a list of parameters that we look at and if posture VA is gonna give us a value of a so there's actually a shortcut because the original Lisp said quote went quote a so only the posture of a is a lot easier actually when you think about it still working we're good still working in the right direction so what we're looking at then is the basic workings so you operational schematics is to evaluate an expression so we type an expression in and then we get a response back it's purely interpreted which means you don't write a program like we do in an imperative language we don't have main we don't have variables we don't have anything like that so you value a function to a function value you can evaluate an argument of a value to a value or you can apply a function to all values so the scheme treats the parentheses S is saw here as the function application so the parentheses here is a application of a function it says run this function so if you're an objective-c program you're sort of familiar with this any other thing Objective C came out at the same time period but they used brackets instead of parentheses and the syntax is actually the same this is a function or a method plus send me the message one and two two plus it's very Objective C like because this comes now for the same language hierarchy but from the same time period and that's the thinking that was going on at the time so you can have a negative number why not we'll do that in a few minutes but yeah it's a value as long as you don't put a space in between I'm going to show you something about spacing in a few minutes - that's gonna I'm gonna hopefully save you some time and the energy in the end when you start writing this stuff so mine's almost done so apparently some of yours is almost done - half the room I probably was the last person to click downloads with Frogmore 88-89 an anticipation I'm gonna close this window here I'm almost afraid to close it ok and this is a that's a scheme function actually all right here we go 92% we're getting there 93 all right so one two three we have an error in this particular case because the object 1 is not applicable we can't we don't there's no such thing as a 1 so if we actually typed in 1 2 3 here without putting the apostrophe here we weren't out doing it we're trying to apply 2 & 3 to the function wine and we'd actually get an error message 99 almost there yeah there we go so I'm gonna assume everybody else's beat me to this so I'm gonna double click on it run through the install for you real quick to tell you what to do which is really easy actually so here we go dr. racket gonna go next and I'm gonna put it in the racket folder here next yeah it's gonna tell me that it appears to be an already at record in there so no I'm not gonna install it first I'm just gonna prick on yes and I know I have to uninstall okay let me uninstall real quick you don't have to uninstall if you don't have it installed but unfortunately I have to uninstall it right now I probably could have just left it I guess as you can see it's loading a bunch of files and it's an old Windows program actually so it's not using the registry it's not using it's just bunching a bunch of individual little files and it's storing anyway while this is going out proceed forward here so we know about the constants versus the values and so we get the constants by using the astra apostrophe is just shorthand for the quote and then we also have this thing called a conditional evaluation so in a conditional evaluation it's sort of like an if-then-else scenario that we get in regular evaluation of other functions so if a condition then a condition else' condition which is the same form that we're looking at if we start using the word the cond Co ND which is a conditional expression a conditional statement we'll see examples of this coming up here's this condition that X is larger than 0 and in here people go oh how do you know you write it like this well because X is larger than 0 because we're applying the larger than evaluator with the two items X and 0 which is how we're gonna come out with that and then taking this here and applying it to this to say okay well then take this and divide it out by well what are we going to divide out we're gonna take a hundred so the condition is comparing these two with a hundred divided by X or X divided by 100 and reading it and then we're gonna say well then if X is equal to 0 then return 0 else take 100 tons of by X in terms of the expression so well that's one of the things just sort of have to get used to thanks regular-sized you do the duck yes force it have it open okay good okay so if you're running through the install all right from the beginning so I can see it correctly now friend supposed to probably done with the install hit next hit next huh there we go so it's like the director you're gonna put it into I'm just gonna put into racket install and then wait a few minutes well puts all those files back that it just took away moving right along up next defining a function we can also define functions with names so in this particular example this is the one I'm gonna use actually we're gonna run factorial so this is says define factorial X so the basic function form for defining a function looks at the word define as in terms of the keyword this is we're gonna define something we can only define functions there's nothing else in the language so there's a no-brainer here we give it a function name would give it a parameter list so function factorial is the name X is going to be the list of parameters and then we have the function body and so we don't have like the opening and closing squirrely brackets and stuff because we don't have scope we just have a local scope for everything there's no scoping environment with this instead we say if X is equal to 0 return 1 so we have an implicit now ex excuse me else rent and then here's our here's our recursive part for those people who don't like recursion we're running factorial inside effect or L and we're saying X minus 1 essentially so we're gonna mind we're - in one from one icing X so I seems checking to see how fast the install is going alright so now we're gonna that was it that was the install so I click on finish to run it and it will open up if he doesn't open up automatically go to the Start menu programs racket and then you want to click on doctor racket when you click on doctor racket you see this coming up here pushes the racket logo happy or hopefully are here already I'm probably the last one so it takes a few minutes this is a loading in an emulator on top of another operating system with some recording software going on which is why it's running so slowly yours will probably run faster and your download probably run faster as well so once it opens up we're gonna get this funny-looking screen that shows up it's not very user friendly so I'm going to explain the screen to you in a few minutes here there we go and the first thing is gonna do it didn't do it for me because I already have a language it's normally gonna it's normally going to and tick my current settings it's just weird because I uninstalled it but anyway down here on the bottom you're gonna get something that's going to say hey it's gonna ask you for a language okay what language do want it is so if you could click on the language icon next gives me menu item on the top and you say choose a language you're gonna get this little screen to comes up and it's not gonna be very user friendly for the most part because it's not gonna describe well what are all of these languages I can pick it used to be in the past we have these teaching languages and the teaching languages beginning student which is not bad our beginning soon with lists abbreviations wasn't bad because we'd end up having here's with lambda expressions advanced students and that what ended up happening originally is the people that were supporting this in writing this well there were teachers so they were writing special dialects of the language for their AI students to use in the lab you know this is they're basically augmenting the language with these different choices and then so most of them do everything only problem is is the level of error checking the type of responses you're going to get and the support friends this particular case lambda expressions which you don't get in some of the other ones so here's the language you want to pick and it's gonna say well it's not one of the teaching languages we want to go to this one here are our s are our five RS if you don't like this one you can prick you can pick lazy racket actually lays your racket will have a few things where you know shortcuts to it that are built-in but you're not gonna know what any of them are the r5 RS is one of the traditional legacy languages that's very true to traditional scheme and all of the lecture set examples follow this language so if you select it then you're gonna see language RS are five and then you're gonna see memory 128 megabytes or something similar maybe you'll have higher memory footprint it takes a percentage of what's available on the RAM and it sets a memory you can increase the memory to anything you want it to have actually for the purposes of this course so what you're gonna be doing with the assignments you can leave it on the default memory and nothing run into memory problems when you're in into memory problems is the fact that there's no garbage collection so if you have a big ole list of memory big a list of list of items and you load them all in because this is very compatible with test excuse me with text files so you're gonna have your literal you know fill up all your memory and the more memory you filled up the slower the systems gonna run because you don't have that much working memory left and eventually gonna run out of memory so if you ever see the word delay delay delay or something or weight or a paused it means it's trying to figure out what to do cuz a pimp does no more room left in memory so that way you increase your memory so now that we're in racket or if we want to switch the language we have this little thing on the bottom but you don't want the error message anymore if you have an error message it's not gonna help you with anything no frills the sub that says take the no frills um oh hold on a second let me take a look record look just keep pressure turn up there clovis I didn't open it back up again close it and open it back up again it should it's not it's not processing it for you because it doesn't know it so it should come back and say something like this and if you close it close if you if it's not coming back close it bring it back up again and it should be resetting it for you I should show the language if it's if it's telling you you haven't picked the language it can't run anything is it working now okay good unfortunately I closed mine just to say close it do as I say not as I do don't close it it's not to bring the pack up alright so now no we're back up here momentarily and I'll show you how to use the screens there's two screens to choose from the top and the bottom the Lazy racket is is a format where in which and this is the format you'll probably end up doing anyway is that you can load something up into the top screen and then run it in the bottom screen or you can load it all in the bottom screen so let's run our first let's run our first function so if we type in an opening bracket and I go plus and I go Space 1 space 2 and I put a closing bracket in there you notice that the entire expression gets highlighted and if you press return you see I see the answer down here it says 3 this is a function that you've just run that you've added 1 & 2 together obviously but this is the function name here so I could do this I can put in the and everything you're running is going to have an opening and a closing bracket it's all gonna be see if that's good all the same syntax so I can go length as an example which is another function and I'm gonna go here and I'm gonna treat this like a set of values so I'm using this apostrophe but I saw before and this set of values them that I'll put in in this book foster feet are gonna be 2 3 4 and then I'm gonna press your turn and it's gonna go what about them I didn't finish I didn't finish the expression the natural thing you're gonna want to do is put a semicolon which I did actually just myself naturally I thought myself with that money there's no semicolon at the end of the line instead you have to close the expression because this expression could go on for days months years well okay well for as long as you're gonna rewriting this thing so I closed the expression and now you see that the whole thing is highlighted automatically for me so if I take the expression up it's not gonna be well okay so it's a bad example because up there goes this is highlighted because this is recognizable and if I come back over here that's not going to be highlighted but this one's highlight because that's recognizable so that's the level of error checking it tries to give you so if I close it and then I press return now I get three again because it evaluated these three items instead of sending this to this so if I do this and I go late one two one two three whoops when you close it again it's gonna come back and give me my first error message because I'm sending a function to a function R as a function argument to a function well not only that but my first function is wrong this function is incorrect because there's no function one defined in the language and I'm sending arguments two and three to one I don't understand that one and then I'm also sending this to this so it doesn't understand what this is essentially but I could actually send a length to make this a correct function so the application not a procedure expected a procedure that can be applied to an argument given one argument to three doesn't work so I could experiment around with it a little bit and I can go okay well what about this what's going to happen here and I'm gonna go plus one two and then I'm gonna press your charge and I'm gonna go oh I forgot to do that closing again I'm gonna press return again it's gonna say impair so there was a contract violation with an MC CDR so I'm going to show you CDR in a few minutes along with car and along with built in and this is this is a given three given three it didn't know how to occur length because length is a 1 so we have list processing and okay so this is where CDR car and some of the cons and some of the other built in Lisp functionality is taking over and it's changing my logic a little bit because I have list processing functions that are built-in that are going to manipulate my list for me automatically and it doesn't understand why you're asking it for a length when there is no length when you're not giving it anything for the length because the CDR removes an item there takes in returns just the end of the list or does certain things to it so it wants things in a certain logical order in order for it to to process what it needs to do up here at the top we can do the same thing so down on the bottom I'm gonna leave that error message alone there I can get out of it let's take control see yeah all right let's move through the top because I posed my bottom actually I suppose stop here we go there we go now I'm back so up in the top window I'm gonna type the same thing in again because we don't have we have a limited vocabulary right now I'm gonna go +24 I'm gonna press return nothing's gonna happen but if I come over here to the right hand side and say run then it's gonna run for me and you see now I have four plus two it's just six and this result showed up down here so on my desktop I actually put a scheme I believe I put a scheme function in here but let me just take a look here let it up in WordPad I did I put a scheme function up here so I'm going to show you something that's very handy which is what people do in the real world they go file whoops open and I'm gonna pick this scheme function and I'm gonna go open and it's gonna open up a new scheme window here I'm gonna hit run it's kind of down here so it's okay now any want me to do well I want you to run this but yeah so now I've loaded it up and I put it into memory and what does this thing do well it gives me a reply and it wants to reply s and s is going to string so if I type in and reply and the S is high if it's equal to hello it's gonna come back and say hi if it's a substring it doesn't understand it's gonna come back and say huh well understand yeah so to run the punch and I would go like this and go reply hello it says come back and says hi cuz in my conditional and just explain functions to you I've used the word EEF to define a function the name of the function is reply and the reply takes on one parameter s so I send s to reply yeah and the string isn't the string that we're looking at is s it's larger than or equal to the string length of 5 it's just smaller than a certain amount actually larger than well anyway long story short if it's equal to hello take a look at the substring that we're pulling out of the string you come back with high if not huh so if I run the same function again and down here I'm gonna run the function in them basically showing you this because I want you to see how you can run functions and how to use it's an orientation to the environment so I'm just gonna put a big old string in there I guess whoops and then I'll close it and they'll press it huh and now it comes back and says huh so all of all you're gonna do is going to be sort of like in this kind of syntax this is a more sophisticated way of writing and I'm going to show you a simpler way in a few minutes I can also come back let's say for example to this lecture that we had opened up and take that factorial that factorial example oops here it is here nice little factorial function here I'm gonna go copy and then I'm gonna go back to that scheme window over here I got paste it up here I can also paste it down here if I want to I can go back here and paste it right here press return it just doesn't do anything but then now I can run it I can go out here and I can say factorial factorial let's do eight and then I run it comes back and says 40,320 or if I want I can click up here I already have it loaded so my question what's gonna happen let's just face it didn't up here if I pasted it up here I'm gonna have to press run runs gonna run it in here so now reset my memory and ran what I put up here it doesn't do any garbage collection so my reply is still in here in fact if my reply is still up here actually here's my factorial underneath it so it's not like writing a program so now I can still come down here and go factorial to comes back and says - does it not understood the function and this is a little bit easier function I think to work with this one up here does the reply it's a little bit it's an example I gave you actually for one of the assignments that you're gonna do so what you're gonna do for the assignment is actually kind of taking analyze some data and I some lists do stuff - you know - and figure out well what am I gonna do to analyze the results from this experiment that I've conducted so let's go back to the lecture firm unit for a minute or two slapped on slide number 21 oops here we go so I kind of explained the the shorthand for the quote which is the apostrophe and then the conditional evaluation here using the condition Co ND and so we now I can see this definition of the function factorial X that we just looked at in all of the under the r5 s6 or whatever it's called that the language I gave you all of the examples in this particular lecture will will work in there so you just cut and paste them out and stick them in there never work just fine if you select one of the other languages you may not necessarily have as much luck but some of them will work so what Ellen of happening is you'll go online you'll find examples and you'll take a look at those examples and you know what language is this it's lazy scheme it's lazy racket oh it's you know you know advanced students or something and I usually they tell you what it is and then you set the language correctly because it's yeah one language mean it really is different languages so but the concept of the scheme is the same and these concepts here are universal among all of the different languages the entire language of scheme is made up of six functions and here they are as well in fact the six functions are right here the entire programming language is composed of these and here they are here six basic functions the cons the CDR the card equals the atom the condition the condition you're going to use most of the normal everyday dialects don't use it anymore we just use if-then-else of that instead so so what are these six basic functions that control every function that you're right here's one of them in particular that comes in handy and while I'm following while I'm giving you this PowerPoint stuff if you're you know bored leave your scheme up and start typing this stuff in every one of these examples should work just fine so like as an example of a car sniffing I flipped I can flip so car ABC returns a so you should be able to type in or what was it a b c and it returns a there's something else i forgot to show you spaces are important if you put an extra space in let me go back to the plus 1 and 2 and show you something um so you don't put anything at the end you just hit the return key and you get the response that comes back but let's say for example I put an extra space in here that's probably not going to matter but in here I go to 3 space space the end up no say it so now ok so this one is going to keep it some of the other languages would actually come out with an error if I could do this go + 2 3 2 3 it's going to take it as 23 it's not going to take it as 2 and 3 so sometimes it's best not to put extra spaces in this language is forgiving some of the other ones the beginner student should come out with an error message actually if let's do it I'm trying to generate an air out of this no not gonna do it okay that's a lie story sure if you're getting an error message to check your spaces because sometimes the spacing has been a space delimited and it's read and interpreted by your spaces so sometimes it doesn't read the spaces correctly alright so back to the useful functions and as I was demonstrating feel free to cut and paste and put them in there or just type them in there so CDR returns the list so this returned a it doesn't get rid of it it just returns the first item on the list because what you can do is take the first item on the list run it through a function then take the first day get rid of the first item use it use another one he's a CDR get rid of it take the next item on the list take the next item on let's take the next out of minutes you're never gonna lose track of where you're at in the list so this is opposed to taking a big old spreadsheet in like an Excel and going down each one of the columns and yeah what colon was like on there's kind of an automated way of traversing through the different columns so car returns the first element of the list here who's gonna return a CDR returns the list that results from removing the first element from the list so you'd do a car a you know you do a car on the list and then you do a CDR then you do a car a CDR car senior what ends up happening especially if you do this recursively you traverse through and you have an empty list at the end because you've gone through all the data and you've taken each item one by one as an order that comes through and that removes it from the list so here we have ABC returns B and C CDR a just returned to the empty list and you're done so cons constructs a list by inserting this is not condition its cons construct constructs a list by inserting the first item at the front of its second argument which should be a list so cons x takes now we have X a B so we just added X to it so if you've got a whole bunch of stuff that's coming out you take the data you put it in and you're saying you know Conn's this and then you build the list so you build the list up you break the list down go back and forth you can also do it using the lambda expressions and then here we have the form of the lambda lambda L which is car car L and L is the expression above it's called the bounded variable you know you're running she said you would all have variables in this language you can have variables in this language if you want variables in the language so lambda expression here can be applied so we have lambda L car car l with ABCD does the same thing so the expression a is its value that's returned so a2 ABCD now we can also make function definitions and scheme and we don't have to use names we can actually or me this particular case we're using names using cube but we can also use a lot of expressions for the same thing same thing that we did here so it's just a matter of saving you know using the functionality and making the best of it so in turn we have a function defined can be used to define functions and has two forms so here to bind the symbol to an expression because a define pi is equal to the 3.14 our yada-yada looks like a function call but this is a variable now so yeah we don't have variables okay we don't go integer I I is equal to 5 I plus plus this is really a function call but we're using defined so I'm you're trying to use define this PI's actually uses a function it just returns this number so if I said define pi and I type in PI you know I'm gonna get this substituted value because pies aren't really taking on any parameters or anything it's just gonna return this value to me so it's kind of like people working like a variable but it's really a function because this is a functional language and everything is a function so it's kind of interesting how that works out so here we have defining PI to PI this is going to be two times pi and to bind the names of the lambda expression here we have can define cube x as X times X times X times X this is where we're getting missed times here so an example of running this it would be cube 3 this one here doesn't you just type in PI and it would run for you there's no parameters for this ones but if you typed in PI we're just gonna return 3.14 whatever put in their precision wise alternative way of defining it would be used to find cube lambda X with x times X times X times X so here we have expression evaluation process that we can go through and Donald won't know I have to my bullets here but those are bullet points so for the normal forms the parameters are evaluated in no particular order so the parameters come in and they're just a value you can't expect there's no reason why you want to expect the first one second one third one there's no order to it and the values of the parameters are substituted into the function body and then the function is running with those parameters and then the function body is evaluated obviously and then the value of the last expression that is evaluate is returned from the function and sent back to the function if we're going to essentially run a recursive function or its returned to the user if it's not going to call itself again so special forms use a different evaluation process special forms are going to be forms that are created by different languages so some of the different language dialects have special forms of functions that are designed to special purposes in terms of the language evaluation so let me homie you have this thing called map and that is a predefined function calling scheme that can operate on multiple lists of arguments so we have map so before so now we're jumping ahead so before we had one value one value one value one function call one function call one function call let's quadruple it so now we have one list and another list so map takes the first list and applies it to the second list once it can apply one it's gonna apply a plus so it's gonna take item first item in one list and add it to the first site in the next list so that's some nice automation if you've ever tried to do that by hand you usually have a spreadsheet maybe it's two separate spreadsheets and you try to add them together because or not nobody knows how to figure how to do it sell correctly or maybe it's not in the spreadsheet maybe showing paper printouts and stuff so somehow digitize it get it into a list form take the list send it to the function get the function to add them first column here first column hearing forget it gonna merge together or you better yet add three of them to it better yet add four of them or five of them this guy's unlimited which is why you're gonna run out of memory eventually if you have a small memory footprint and you're loading in tons and tons of data you're gonna need to probably increase your memory at that point but working memory for your examples right now is pretty pretty small no memory problems here's combined with the Lamba expression if you like to use live expressions and the a B with a list AV so here's the functional form as we remembered before we're gonna see some more examples but these are the three functional forms so we saw with the Lisp we had the composition applied to all and then the function we just saw a few minutes ago which is that functional form so in the composition we have cube and then we're gonna apply towards and then what we've done here is just nested it a little bit we put a 4 + a 2 in here and this gun's is going to be substances this is a function called it did add which is gonna be substituted into the function called add in multiplication which is going to be substituted into the function called a cube so we can basically do it break it down from all of its different levels and then the applied to all with the math car so remember that math car message we saw kinda known about 20 minutes ago or so when I was typing stuff in it thought I was running a map car because of the syntax that I was using it was expecting something but didn't get that so the math car cube if I actually typed in map car cube and ran this which is very similar expression to what I put in before it takes each one of the expressions and applies it towards the function so the apply all is basically the map car so the function map car that applies a function to all of the elements of a list the value returned from that car is the results of that each one of the list items being processed through the function that were running so it thought I was doing a map car sent it something like but I think I did plus or something I'm not quite sure what I did but the syntax was supposed to be a play each one of these items by all to this function so sometimes it comes back with those cryptic messages and you look at the message and you go ah what are you talking about in this particular case when I saw map car I went oh that's what I was doing wrong format so it's possible to define functions that build scheme code and requests its interpretation at the same time and we have this thing called eval so we can put an eval in here evaluate an expression and then use it for an else so it's basically explicitly telling us to evaluate it now don't wait just evaluate it now so you're defining a function that builds a scheme code and then requests this interpretation while the function is being run for example suppose we want a list of numbers that must be added together the parameter is a list of numbers to be added adder which is the name of the function inserts a plus operator and evaluates the resulting list so in this particular case we'd be running it with adder one two three four five it's going to turn ten this particular case you don't have to write anything that's sophisticated for the programs that kind of stuff but you're gonna write for this class so now we have apply so now the scheme function apply invokes a procedure on a list of arguments so apply plus it turns 10 so because we're gonna take one two thing and then we're not running or running a function call and a function call but because we're saying apply we're taking this as a list and this is the key here because it's not we could just put the plus in front of here we could rewrite this whole thing and go and then we'd add everything together if we did plus one two three four five because we took that way but we could nest this inside of something else if we wanted to and then this could be populated from another function call if we wanted to so it depends on how you want to write the function call and what how what you so you're gonna make of it as to how you're gonna write the expression but the apply comes in handy let's say we also have imperative features heard of language features so we can set a very which binds a name to a mate a value to a name we can do as a set car replaces a car with a list or set CV R which replaces a CBR of a list so there are some examples we can define a is 1 2 3 when you type in a you'll get 1 2 3 why would you want to do that well maybe you don't want to keep writing in a whole big list to stop and you know that this is you know got 20 items in the list and you just want to call it a then you could take a and add it to B or a and added subtracted from a scene or something and actually experiment you had your question earlier with a negative number but a negative number in it just works like a number it's the regular old number line it's well I just remembered for some strange reason I saw this I remember good question so this least one two three these two line numbers by the way so you're not gonna get that we've seen what it looks like GNU scheme has the lane numbers on it which is interesting so your different scheme dialects are gonna give you a slightly different interface in fact the gnu scheme i don't believe has the split-screen but it might now older versions of it ran from a terminal prompt so you just typed in from the terminal prompt you just put your stuff in there and it works for you um so here we have a cons 10a there's gonna be 10 1 2 3 a you notice it says well what happened with a a is still 1 2 3 because you defined a as 1 2 3 so although you're using it like a imperative language you know like C or C++ source calling it a you're not changing a so we did this and C we said a is equal to 1 2 3 ok so add for DES a would be equal to 1 2 3 4 well in scheme a would still be equal to 1 2 3 because we defined a as 1 2 3 so it's not really a variable it's a definition so we have cons tenday what cons is just going to put in front of this one here so we have a set car a 5 now we're gonna set the first one to 5 now we're setting it so the set in front of the expression actually changes the value so we set it so instead I went to 3 now we have 5 2 3 type in a and we say 5 2 3 so the way this works actually is the list schematics work with a list so remember I start did this entire talk talking about Lisp I said Lisp is a dialect of scheme it's also a dialect of Common Lisp this is a list language for those people who know C++ and are familiar with the concept of the link to list it's a linked list it's all stored in memory which is how you can fill up the memory this is all gonna be linked together nothing goes away there's no garbage collection until you get rid of it so here's what happens and this is what happens in terms of the standard length list we have nodes in each node has a tail and then has a pointer to the next node and then we have you know the next goes to the next node but we don't have to use do not have to use pointers in this language it's done for us automatically but it's implemented kind of like pointers with the memory that you have assigned to the environment so the list is an S expression that isn't an atom it's actually a list data structure this has a tree to it so we have the head and the tail and so here we have a list of ABC indeed looks like this in memory so we have ABC and DNA is the top so when we do cons it's it just says find the first node remove it find the next node remove it doesn't know what's in the node so it's not a little extra set here but I have to mention to you that ABC this could be a function call the number one character a float a double put anything you want in this list it's the same thing you give a C++ with linked lists it's just memory locations storing an item who cares what the item is just put something in there so you no longer have to worry about all the restrictions that you have with arrays and other list structures in other languages where it all has to be same data type or something doesn't matter it's all linked memory has no idea what's in there it doesn't care so now we have a note that the empty list is the probably well in this particular I'd like to look at it upside down call the empty the root but in this case it's Heil the tree so when building a list this is how the Khans the CDR and the cars actually work with this primitive function cond which concatenates a list - a list which is with the co n it's a short for concatenation concatenate an element to the list so here's the element here's the list so if we said con cons a to ABC we defend it with ABC so con a to a B to B see a to b see we get ABC hopefully that shows up for you it doesn't you can't really see the color on your screen but this is a bloom or Scion and this is an orange color icons a to the empty list gives us a we have now have an empty list a cons B a and B with C and D so a and B we see now I have the book together so we just had this tie they mix them together so it's basically just doing concatenation from list item to list item I want to do that we have car so accessing list items themselves get the head of the list so it's kind of like saying give me a head give me a head give me the head give you the head or give me the tail give me the tail depending upon which direction you're traversing through the list but this works with the front of the list so car selects the left sub-tree so if I said you know car ABC well it's gonna be equal to a car a which is inside of ABC well we got a which is the first item it's gonna be in there so it's basically for those people who are familiar with linked lists you're working with a linked list a primitive version of it and that you're not creating yourself but that's the data structure you're working with in enlist in Lisp and also in scheme as well so accessing the list components get the tail of the list CDR so we have the head and the tail CDR selects the right sub-tree this example we have CDR ABC well it's going to return B and C it's gonna do the opposite so pulls the head and then it gives you everything else past the head so it knows what's there I doesn't actually know what's there it just pulls whatever's in memory it's linked up to it which makes it fast because going through the concept of searching and sorting through a list it's easier to go through and blindly and just take everything than it is to actually go through each one of the items especially if the search space is big so here's car and CDR in terms of deconstructions of car and CDR can deconstruct any list and so we can put this combination together with combinations and we can go see here and we have a car on the back so we're gonna get the tail get the tail get the tail and then or you know get the front which is why I was saying before you do it a car a CD or a car is severe a car severe and you can actually just go through each item one item at a time so special abbreviations are here for sequences of cars and CD ARS with the CA are one of the language supports special abbreviations and those are the special abbreviations one of the teaching languages actually it said with abbreviations this is what it's referring to instead of because you know it's really a hard to type in CA r and CDR it's easier to type in C in our you know it's one character it's kind of like Linux people UNIX people you know it's all hand-done so there's shortcuts and there's ways of habits that people get into which is why we have so many dialects because you know they just write the new dialect and you just put it in it's a language file in the form of the text what is this just a lookup it means this is equal to this this is equal to this this is it's kind of like it could take everything and rewrite your own syntax but it's all the same expressions it just says different expression names the form of the expression is identical regardless of which language you're using the language is just a dictionary lookup of all of the commands that you're using cuz some of the people like BEF instead of define because they don't want to type out define well I get some of those crazy languages and you can write your own language actually and have people use it so I'm gonna say using car and CDR if you're doing that you just contribute to the GNU license actually get out there and all the some people are gonna be using the ITU language everything starts with an i I CDR I see a are I define I you guys I think you know whatever and actually really or not there's languages out there I don't think we want to widely distribute that though might not make us look too good all right so the kind of seed here here's an example must game functions operate over lists recursively and here's our recursive list or we're taking length and at the bottom we're running late usually you see the recursive call at the bottom there's just two examples one's doing a some Natalie's calculating other late in this particular case I just run the length but we wanted to create a new function called le in and steadily you know so you want to dry your own function so this was gonna return the value of three the sculpturing value of six visits gonna do the summon basically this is the call here excuse me this is the function call at the end in here we have the recursive car and see the yard that's being run on some so it's calling some and doing a CDR on one item of the love the parameter that's being sent to it so the down here on the bottom is the function call the function above it is doing the research cursive call here with me is an example some useful scheme functions we actually saw a couple of them already the plus the - these are functions they're symbols but they're just same thing as adding typing an ABB s um - it's the same stuff actually works different dialects for different languages obviously equality we can use EQ question mark is this equal this one in this one so we can see did we get the same results every time we do it and we can take a thousands of numbers and through this list and see which ones are equal and cannot say hey 50% of them are equal oh man we're on the right track they're heading towards the right direction in our research or is it null is that empty we can test for an empty list we can also do type checking on a list to say is it a list is it a sub expression isn't an atom is it a name is that a number is it zero did we get anything out of this and come back and says zero sorry go back a try it again we didn't find anything that matched and we can all look at make list arguments to make argument into list as well so we can take the list ABC it turns it into a list so if we don't have the data into a list form we can make it into the Vista for them as well so how this game really works does a read evaluate or print loop so it reads the information and evaluates it prints it to the screen comes back in reads more information you value it so it puts it back to the screen reads more information you're at it until it runs out of stuff to do and then just sits there and blinks at ya it just says that it doesn't really do anything so I never particularly evaluation for the input we've seen this so I'm not gonna go through the more intricate detail details of this so and I'm not gonna go through the rest of this either in terms of the read evaluate print loop because this can it's a little bit dry but I will talk about polymorphism for a second because that's what I was mentioning before it doesn't really know what's in the list so we have polymorphism act and this is not object during a programming language by the way either it's a functional programming language but we have polymorphic functions that can be applied to arguments of different types so as an example the function length can say a function of numbers you know length give it numbers length give it characters give it a combination doesn't know what it's getting it doesn't really it matter what it's getting it's just counting items and our anthems we can say function 0 is not polymorphic if we're saying 0 10 so we have some functions that are polymorphic some functions that are not it depends on the design of the function this applies towards your user-defined functions as well as the built-in one so if this one said 0 10 and a 10 was a string it come back and saying I'm sorry I don't know what you're talking about I don't know if I'm zero or not cuz I'm not a number and there's no types so it takes a look at the data and that determines the data type by what it finds so if it finds a string then it says oh my string it finds a number automatically were a number so it's kind of interesting that way as well so 0 with an object the object is not the correct data type it doesn't know if it's 0 or not and here it's coming back true or false actually as a value at a equals or 0 is it is it there so we can define global variables as well but by default everything is static so I predefined function defined merely associates the name with values so define mousses ABC then we go moose define yak define all of it basically what it's doing is creating a local variable name that's associated with a formula or a function calculation that you're willing to do makes a global once you load it in and you've got it in fact if you load it into the top screen makes it all available but in terms of variables themselves think of them as function calls or identifications and not necessarily variables in the traditional sense of programming we also have the unnamed functions as we've seen but it's really hard to run an unnamed function so you run the unnamed function with the data automatically and then it all works correctly but you know see here we have functions that are values and however we do that well the function can exist without any name if it's just a value the function is ad something I've divided by this and do something else with it and then send that to a factorial so we have some that instances in which we don't want to commit to a name too much work we're never gonna use a game I'm just gonna run it once it's gonna be a parameter to a function call and don't bother giving it a name you don't have to so the notation is based on the lambda calculus as we've seen before and that's the formal form for divinely crucifixions and their properties a lot of recursive functions we're gonna have functions inside but are just gonna be calls to itself they may not necessarily need a name here's some examples the x 10 by 10 we can define in fact over here the alternative form of the definition where we've got defined square x lambda X but we're gonna say define sq but we're gonna use lambda X instead of square x in there and it's gonna basically have the same functionality but we're calling it by sq here we've defined it as square X but it's not necessarily being used I mean it depends upon whether or not you want to put names have an unnamed function so functions and scheme are all high order functions or higher order so the functions can be returning values and then return once per function call and that value is substituted in so to find double in triple treble and quadruple in etc and so forth or define and then here we go a value to itself so in evaluate which one it's going to be and what essentially alright so we don't really need to know that much about higher-order functions but they can be used again functions can be use those parameters as well just to reiterate that point and functions as parameters considering these functions here we can insert them in different ways these parameters you named are nameless we can also put different numbers in I'm negate here it's gonna give us the opposite actually as well now we can have double invert negates in terms of the function calls so we're are very different well the same function it's just that they're using different function colors themselves it's really the same function over and over again well the functionality environments a special form of the let and the let with the asterisks are used to define local variables so if you really wanted to find a variable you can say let a is equal to 1 2 3 well better yet just say a 1 1 2 3 and the function a would return 1 2 3 so both established binding between variables and expressions so what does finding in power parallel and the let with the asterisks does the binding in it in the order in which you give it C so that's everything you ever wanted to know about scheme and lucky for you the next assignments non scheme but the last one is for today so now pause this video soon as I can get back out here and go over the assignment next "
